<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kubernetes on kelvinji2009</title>
    <link>https://kelvinji2009.github.io/categories/kubernetes/</link>
    <description>Recent content in Kubernetes on kelvinji2009</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 31 Jul 2018 12:07:48 +0800</lastBuildDate>
    
	<atom:link href="https://kelvinji2009.github.io/categories/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Kubernetes101</title>
      <link>https://kelvinji2009.github.io/blog/kubernetes101/</link>
      <pubDate>Tue, 31 Jul 2018 12:07:48 +0800</pubDate>
      
      <guid>https://kelvinji2009.github.io/blog/kubernetes101/</guid>
      <description>Kubernetes 101 原文链接
几个星期前，我的工作任务变得很有趣：部署Kubernetes集群并编写相关工具，以便开发人员可以在他们正在处理的分支中部署代码，并测试其更改。
在那之前，我一直想学习Kubernetes，因为它听起来很有意思（如果你是希腊人，你会觉得这个名字很有问题），但我从来没有机会，因为我没有任何东西需要运行在集群中。所以，这次我抓住机会，开始查资料，但所有的资料（包括官方教程）似乎太冗长，结构也不合理，所以我有点沮丧。
无论如何，经过几天的研究，事情终于有点眉目了，我开始疯狂在不同的机器上部署，迅速让我的AWS账单暴增了数千美元，这才像一个2018年的有自尊的后端开发人员。因为我的简历现在说自己是个“Kubernetes专家”，一个想法立刻诞生了：为什么不把我对这个系统的宽泛理解以及我已经耗费了几个小时的研究所收集的知识让更多人看到？虽然我无法说服自己不应该再写另一篇漫无目的的文章，但是我很快就明白了：
这就是那篇文章。
我在现有文章中遇到的主要问题是，在深入研究具体细节之前，我找不到的任何内容总结了这些组件是什么以及它们如何组合起来的高级概述。 而这种高屋建瓴的呈现方式是我学习最好的方式。我是以这种方式来写的，希望它也适合你。如果你知道任何描述了Kubernetes如何工作，而且让人容易理解的专家级的文章/教程，请不要告诉我，因为你在我需要你的时候你在哪里，现在我写了我的文章而你却没有及早把它拿出来。
另外请记住，我实际上只学习了Kubernetes一个星期左右，所以学得不会非常深入，有些可能是不准确的，尽管希望没有什么错误，这里的信息应该足够让你达到运行简单集群的程度。
话虽如此，最后我发现Kubernetes中的概念还是非常简单的，虽然我确信有很多东西我还不知道。但是，我知道的事情就足以建立一个集群并让我们的应用在其上运行，而且我很确定它们足以让大多数人知道如何开始。
基本概念 我们需要做的第一件事是详细介绍Kubernetes的各个部分：
 控制平面(Control plane)：顾名思义，这是控制其他一切的部分，这也是我一无所知的部分，因为我们只是向亚马逊付费，让亚马逊帮我们处理这部分。我的理解是，这是最好的决定，除非你是谷歌，否则你应该付费给一些公司，让他们为你管理。
 节点(Nodes)：节点本质上就是一台服务器，就像您付费的物理机worker一样。 这是所有代码部署的地方，将裸服务器变成节点的方法是在其上安装Docker，kubelet，kube-proxy和其他一些东西。本文假设您的群集中已有一些worker。
 容器集(Pods)：pod是容器集合。 这是您的代码所在的位置，通常每个容器都有一个pod，尽管您可能希望将一些密切相关的服务放在同一个pod中。 pod在单个节点上运行（但是一个节点可以运行许多pod），这意味着pod中的所有容器将具有相同的IP地址，并且它们可以通过连接到localhost上的彼此端口来相互通信。Pod在部署后无法更新，只能删除或替换它们。
 部署(Deployments)： Deployment是您将pod实际部署到群集的方式。 您可以在没有Deployment的情况下运行pod，但如果没有Deployment，则无法轻松指定所需的副本数量，在失败时自动重新部署pod，回滚到早期状态等。Deployment使代码生命周期管理变得更容易，并且您可以使用它来使Docker镜像在Kubernetes上运行。
 服务(Service)：服务允许您从一个pod打开端口到其他pod，并指定一个pod的DNS名称，以便能够查找并连接到群集中的其他pod。
 入口(Ingress)：Ingresses是你如何告诉你的Ingress控制器（通常是像Traefik这样的web server）向外界暴露什么，以及在哪个路径或主机名上。 入口将https://some-hostname.your-cluster.your-company.com映射到将实际应答该请求的pod。本教程也假设您已经配置了入口，虽然设置Traefik来做到这一点不应该非常困难（在用他们的教程时请使用Deployment方法）。
  所有这些都可以使用命令行的kubectl创建，或者更安全地通过YAML文件创建，该文件将包含您要部署的内容的定义和详细信息（然后执行kubectl apply -f &amp;lt;yaml file&amp;gt;。
概括地讲，您把容器放入pods中，这些pods将由deployment创建和部署，其网络将由service处理，并添加ingress以便外部世界可以访问您的服务器。
让我们逐个介绍这些部分，看看它们的YAML配置是什么样的。
The Pod 让我们看一下将在容器中运行redis镜像的pod的YAML配置。 请记住，pod并不是持久性的，所以你几乎不会直接使用它。 相反，您将使用deployment间接部署pod，我们将在下面介绍。
以下配置示例仅供您进行修改。 你只需要看看它，然后继续阅读，不要停下来惊叹它的美丽。
apiVersion: v1 kind: Pod metadata: name: my-pod-name spec: containers: - name: my-redis image: redis ports: - containerPort: 6379  正如您所看到的，它非常简单，您添加了一堆Kubernetes特定的东西，每个都只是复制粘贴，然后您声明此配置是为Pod，给它一个名称，指定在其中运行的容器和他们监听的端口，请删除整个文件吧，你已经准备好了！</description>
    </item>
    
    <item>
      <title>为何说kubernetes是新一代的应用服务器(译)</title>
      <link>https://kelvinji2009.github.io/blog/why-kubernetes-is-the-new-application-server/</link>
      <pubDate>Wed, 18 Jul 2018 21:53:43 +0800</pubDate>
      
      <guid>https://kelvinji2009.github.io/blog/why-kubernetes-is-the-new-application-server/</guid>
      <description>为何说kubernetes是新一代的应用服务器 原文
你有没有想过为什么你要使用容器部署你的多平台应用程序？这只是“跟随炒作”的问题吗？在本文中，我将要问一些挑衅性的问题，以说明为什么Kubernetes是新一代的应用服务器。
您可能已经注意到大多数语言都是被interpreted并使用runtime来执行您的源代码。 理论上，大多数Node.js，Python和Ruby代码可以轻松地从一个平台（Windows，Mac，Linux）迁移到另一个平台。 Java应用程序更进一步，通过将编译后的Java类转换为字节码，能够在具有JVM（Java虚拟机）的任何地方运行。
Java生态系统提供了一种标准格式，用于分发属于同一应用程序的所有Java类。 您可以将这些类打包为包含嵌入的前端，后端和库的JAR（Java归档），WAR（Web归档）和EAR（企业归档）。 那么我问你：为什么要使用容器来分发你的Java应用程序？ 难道它不应该在环境之间轻松移植吗？
从开发人员的角度回答这个问题并不总是显而易见的。 但请考虑一下您的开发环境以及由它与生产环境之间的差异引起的一些可能问题：
 你使用的是Mac，Windows还是Linux？ 您是否遇到过与&amp;rsquo;\&amp;lsquo;vs&amp;rsquo;/&amp;lsquo;作为文件路径分隔符相关的问题？ 你使用的是什么版本的JDK？ 你是否在开发中使用Java 10，但生产使用JRE 8？ 您是否遇到过JVM差异引入的错误？ 你使用的是什么版本的应用服务器？ 生产环境是否使用相同的配置，安全补丁和库版本？ 在生产部署期间，您是否遇到过由于驱动程序或数据库服务器的版本不同而导致的JDBC驱动程序问题，而在开发环境中却没有出现？ 你有没有遇到当你要求应用服务器管理员创建一个数据源或一个JMS队列的时候，它却包含一个错误的字符？  上述所有问题都是由应用程序外部因素引起的，容器最重要的一点是您可以部署所有应用程序（例如，Linux发行版，JVM，应用程序服务器，库，配置以及您的最终应用程序）在预先构建好的容器中。 另外，执行一个内置了所有内容的容器比将代码移动到生产环境并尝试在不工作时解决差异要容易得多。 由于它很容易执行，因此将同一容器水平扩展多个副本也变得很容易。
强化你的应用 在容器变得非常流行之前，应用程序服务器提供了几个Non-functional requirement，例如安全性，隔离性，容错性，配置管理等。 做个类比，应用程序好比CD，应用程序服务器就好比是CD播放器。
作为开发人员，您将负责遵循预定义的标准，并以特定格式分发应用程序，而另一方面，应用程序服务器将“执行”您的应用程序，并提供可能因不同“品牌”而异的其他功能。 在Java世界中，应用程序服务器提供的企业功能标准最近已在Eclipse基础之下有了新的发展。 基于Eclipse Enterprise for Java（EE4JEclipse Enterprise for Java）的工作已经诞生了Jakarta EE。 （欲了解更多信息，请阅读文章Jakarta EE正式发布或观看DevNation视频Jakarta EE：Java EE的未来。）
继续CD播放器的类比，随着容器的提升，容器镜像已经成为新的CD格式。 事实上，容器镜像只不过是分发容器的格式。（如果您需要更好地处理容器镜像以及它们如何分发，请参阅容器术语的实用介绍。）
当您需要向应用程序添加企业级功能时，才能体会到容器的真正好处。 向容器化应用程序提供这些功能的最佳方式是使用Kubernetes作为它们的平台。 此外，Kubernetes平台为其他项目（如Red Hat OpenShift，Istio和Apache OpenWhisk）提供了良好的基础，可以构建和部署强大的生产级别质量的应用程序。
让我们来探索其中的九个功能：
1-服务发现 服务发现是确定如何连接到某个服务的过程。 要获得容器和云原生应用程序的诸多好处，您需要从容器镜像中隔离配置，以便在所有环境中使用相同的容器镜像。 应用程序的外部化配置是12-factor应用程序的关键原则之一。 服务发现是从运行时环境获取配置信息的方法之一，而不是在应用程序中进行硬编码。 Kubernetes提供开箱即用的服务发现。 Kubernetes还提供ConfigMaps和Secrets以从应用程序容器中隔离配置。 Secerets解决了当您需要存储凭据以连接到运行时环境中的数据库等服务时出现的一些挑战。
使用Kubernetes，不需要使用外部服务器或框架。 尽管您可以通过Kubernetes YAML文件管理每个运行时环境的环境设置，但红帽OpenShift提供了一个GUI和CLI，可以让DevOps团队更容易管理。
2-基本调用 在容器内部运行的应用程序可以通过Ingress访问进行访问 - 换句话说，就是从外部世界到您正在暴露的服务。 OpenShift使用HAProxy提供路由对象，HAProxy具有多种功能和负载均衡策略。 您可以使用路由功能进行滚动部署。 这是一些非常复杂的CI / CD策略的基础。 请参阅下面的“6 - 构建和部署管道”。</description>
    </item>
    
  </channel>
</rss>