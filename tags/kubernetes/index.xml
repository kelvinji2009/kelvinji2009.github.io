<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kubernetes on kelvinji2009</title>
    <link>https://kelvinji2009.github.io/tags/kubernetes/</link>
    <description>Recent content in Kubernetes on kelvinji2009</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sun, 12 Aug 2018 22:19:22 +0800</lastBuildDate>
    
	<atom:link href="https://kelvinji2009.github.io/tags/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>kubernetes最佳实践S01E02：使用命名空间管理资源</title>
      <link>https://kelvinji2009.github.io/blog/k8s-best-practice-s01e02/</link>
      <pubDate>Sun, 12 Aug 2018 22:19:22 +0800</pubDate>
      
      <guid>https://kelvinji2009.github.io/blog/k8s-best-practice-s01e02/</guid>
      <description>kubernetes最佳实践S01E02：使用命名空间管理资源  作者：Sandeep Dinesh, Google Developer Advocate 日期：2018/04/27  原文
编者注：今天是Google Developer Advocate Sandeep Dinesh的七部分视频和博客系列的第二部分，介绍如何充分利用您的Kubernetes环境。
当您开始在Kubernetes之上构建越来越多的服务时，简单的任务开始变得更加复杂。 例如，团队无法创建具有相同名称的Kubernetes Service或Deployment。 如果你有成千上万的Pod，只是列出它们都需要一些时间，更不用说实际管理它们了!当然，这些还只是冰山一角。
在本期Kubernetes最佳实践中，让我们来看看如何使用Kubernetes命名空间来更轻松地管理您的Kubernetes资源。
什么是命名空间(Namespace)? 您可以将命名空间视为Kubernetes集群中的虚拟集群。 您可以在单个Kubernetes集群中拥有多个名称空间，并且它们在逻辑上彼此隔离。 他们可以为您和您的团队提供组织，安全甚至性能方面的帮助！
默认命名空间(Default Namespace) 在大多数Kubernetes发行版中，集群开箱即用，名称空间默认为default。事实上，Kubernetes实际上有三个名称空间：default，kube-system（用于Kubernetes组件）和kube-public（ 用于公共资源）。 kube-public现在并没有真正使用过，而且通常单独隔离一个kube-system是个好主意，尤其是在Google Kubernetes Engine这样的托管系统中。 默认名称空间是你创建服务和应用程序的默认位置，如果你不指定namespace参数的话。
这个命名空间绝对没有什么特别之处，除了Kubernetes工具是开箱即用的设置使用这个命名空间外，而且你无法删除它。 虽然它很适合入门和小型生产系统，但我建议不要在大型生产系统中使用它。 这是因为团队很容易在没有意识到的情况下，意外地覆盖或破坏其他服务。 相反，我们应该创建多个名称空间并使用它们来将服务划分为可管理的块。
创建命名空间 不要害怕创建名称空间。 它们不会增加性能损失，而且实际上，在许多情况下它们可以提高性能，因为这样的话Kubernetes API使用的是较小的对象集合。
可以使用单个命令来创建命名空间。 如果你想创建一个名为test的命名空间，你可以运行如下命令：
kubectl create namespace test  或者您可以像创建其他任何Kubernetes资源一样，创建一个YAML文件并应用它。
test.yaml:
kind: Namespace apiVersion: v1 metadata: name: test labels: name: test  kubectl apply -f test.yaml  查看命名空间 您可以使用以下命令查看所有命名空间：
kubectl get namespace  如上图，您可以看到三个内置命名空间，以及名为test的新命名空间。</description>
    </item>
    
    <item>
      <title>Kubernetes最佳实践S01E01：如何以及为什么构建尽量小的容器镜像</title>
      <link>https://kelvinji2009.github.io/blog/k8s-best-practice-s01e01/</link>
      <pubDate>Fri, 10 Aug 2018 14:26:18 +0800</pubDate>
      
      <guid>https://kelvinji2009.github.io/blog/k8s-best-practice-s01e01/</guid>
      <description>Kubernetes最佳实践S01E01：如何以及为什么构建尽量小的容器镜像  作者：Sandeep Dinesh,Google Developer Advocate 日期：2018/04/20  原文
编者按：今天是Google Developer Advocate Sandeep Dinesh 关于如何充分利用Kubernetes环境的七部分视频和博客系列的第一部分。 今天，他主要讲保持容器镜像尽可能小的理论和实用性。
Docker使构建容器镜像变得轻而易举。只需将标准 Dockerfile 放入您的文件夹，运行 docker build 命令，然后运行，芝麻开门！您的容器镜像已构建成功！
这种简单性的缺点是，很容易构建出大体积的容器镜像，其中包含您不需要的东西 - 包括潜在的安全漏洞。
在本期“Kubernetes最佳实践”中，让我们探讨如何使用Alpine Linux 和 Docker builder 模式创建生产就绪的容器镜像，然后做一些基准测试，然后确定这些容器在Kubernetes集群中运行方式。
根据您使用的是解释型语言还是编译型语言，创建容器镜像的过程会有所不同。让我们一起来深入了解！
解释型语言的容器化 解释型语言，如Ruby，Python，Node.js，PHP和其他语言通过发送源代码到解释器来运行代码。 这样的好处是可以跳过编译步骤，但其缺点是要求您将解释器与代码一起丢进去。
幸运的是，大多数这些语言都提供了预构建的Docker容器，其中包含一个轻量级环境，允许您运行更小的容器。
我们来看一个Node.js应用程序并对其进行容器化。 首先，让我们使用node：onbuild镜像作为基础。 Docker容器的onbuild版本预先打包了您需要的所有内容，因此无需执行大量配置即可搞定。 这意味着Dockerfile非常简单（只有两行！）。 但是你要付出的磁盘大小代价 - 差不多700MB！
FROM node:onbuild EXPOSE 8080  通过使用较小的基础镜像（如Alpine），您可以显著减少容器的大小。Alpine Linux是一款体积小，轻量级的Linux发行版，在Docker用户中非常受欢迎，因为它与许多应用程序兼容，同时仍然保持小体积。
幸运的是，Node.js（以及其他流行语言）有一个官方的Alpine图像，可以满足您的一切需求。与默认的node镜像不同，node：alpine会删除许多文件和程序，只留下足以运行您的应用程序的部分。
基于Alpine Linux的Dockerfile创建起来有点复杂，因为你必须运行一些针对onbuild的命令。
FROM node:alpine WORKDIR /app COPY package.json /app/package.json RUN npm install --production COPY server.js /app/server.js EXPOSE 8080 CMD npm start  但是，这是值得的，因为产生的镜像只有65MB！</description>
    </item>
    
    <item>
      <title>Kubernetes最佳实践：第一季概览</title>
      <link>https://kelvinji2009.github.io/blog/k8s-best-practice-s01/</link>
      <pubDate>Fri, 10 Aug 2018 14:19:42 +0800</pubDate>
      
      <guid>https://kelvinji2009.github.io/blog/k8s-best-practice-s01/</guid>
      <description>Kubernetes最佳实践：第一季概览  作者：Sandeep Dinesh,Google Developer Advocate  原文
Kubernetes很复杂，而且每天都变得越来越复杂。如果你是刚开始使用Kubernetes，或者已经在生产环境中运行了一段时间，那么很难跟上正在进行的快速开发步伐。当你有一个团队的人构建在kubernetes的时候，那么想要跟上其快速开发的步伐则显得更加艰难了，因为你必须保证团队里的每个人都保持更新且能同步到生产环境。
虽然市面上有大量的hello world经验的内容，但是使用kubernetes更多涉及到的是如何运行一个Deployment并通过Service把它暴露给外部世界。Kubernetes本身是白纸一张，基本上可以画任何你想画的东西上去，但是想知道从哪开始画却真的相当困难。
考虑到这一点，我开始根据我在日常与人交谈时收到的问题和反馈，开展题为“Kubernetes最佳实践”（以下是幻灯片和视频）的演讲。这个演讲非常受欢迎，我决定深入研究各个主题。我最初为这次演讲制作了七集内容（我想七集是非常合适的数量），我真的认为这些文章和视频可以帮助你和你的团队迅速提升Kubernetes。
所以这里是全部七集期待给你带来观赏乐趣的视频！ 我现在正在制作下一批视频，并希望得到您对想要观看的内容的反馈。欢迎发表评论或在推特上给我发消息，提出您的建议！
第一季  第一季全部视频  S01E01-如何以及为什么要构建尽量小的容器 在使用Kubernetes之前，你必须构建一些容器。Docker使得构建容器变得非常容易，但这也意味着很容易构建低效且不安全的容器。构建较小的容器可以很容易地提高Kubernetes集群的使用效率，而且这是一种不费力的方式。
 博客 视频  S01E02-使用namespace来组织你的资源 一旦过了学习Hello world的阶段，在开始尝试管理在Kubernetes上运行的微服务时，您可能会遇到如何组织它们的问题。随着您的团队的成长并且您需要更多的可见性和控制权时，这会变得更糟。命名空间(namespace)提供了一种管理Kubernetes资源的强大方法，并为k8s的策略和管理提供了基础。
 博客 视频  S01E03-使用readiness和liveness探针来做健康检查 要创建强大可靠的服务需要支持健康检查。虽然Kubernetes具有默认的内置运行状况检查，但它们对于许多应用程序来说可能还不够。 readiness和liveness探针使您能够轻松地为您的应用程序自定义这些运行状况检查。
 博客 视频  S01E04-资源请求和限制 内存泄漏，死循环，未知捣乱分子，过度配置，OMG，这种种问题！虽然Kubernetes为您提供了一个运行服务的强大平台，但如果您没有围绕资源定义规则，那么您最终将陷入困境。 但是值得庆幸的是，Kubernetes为您提供了大量的对资源及其使用方式的控制接口。
 博客 视频  S01E05-优雅终止 Kubernetes中的Pod和Containers需要优雅地处理终止。 Kubernetes可以出于各种原因决定终止一个完全健康的Pod，并且干净地关闭是为您的用户提供良好体验的关键。
 博客 视频  S01E06-映射外部服务 有可能您的服务存在于Kubernetes集群之外。其中一些可能是第三方服务，其他可能是您的团队或公司运行的服务。无论如何，生活在混合世界中会带来复杂性。Kubernetes能够映射这些外部服务，使其感觉就像是Kubernetes本地服务一样，从而更容易消除与外部服务一起工作的距离。
 博客 视频  S01E07-零停机升级集群 您需要做的最重要的事情之一是让您的群集保持最新状态。使用像GKE这样的托管服务可以使这更容易，但是你也可以使用一些其他方法使升级过程更加顺畅。
 博客 视频  从内容审阅到视频和博客编辑团队，感谢所有使这一切成为可能的人，使这个系列成为现实！</description>
    </item>
    
    <item>
      <title>Kubernetes101</title>
      <link>https://kelvinji2009.github.io/blog/kubernetes101/</link>
      <pubDate>Tue, 31 Jul 2018 12:07:48 +0800</pubDate>
      
      <guid>https://kelvinji2009.github.io/blog/kubernetes101/</guid>
      <description>Kubernetes 101 原文链接
几个星期前，我的工作任务变得很有趣：部署Kubernetes集群并编写相关工具，以便开发人员可以在他们正在处理的分支中部署代码，并测试其更改。
在那之前，我一直想学习Kubernetes，因为它听起来很有意思（如果你是希腊人，你会觉得这个名字很有问题），但我从来没有机会，因为我没有任何东西需要运行在集群中。所以，这次我抓住机会，开始查资料，但所有的资料（包括官方教程）似乎太冗长，结构也不合理，所以我有点沮丧。
无论如何，经过几天的研究，事情终于有点眉目了，我开始疯狂在不同的机器上部署，迅速让我的AWS账单暴增了数千美元，这才像一个2018年的有自尊的后端开发人员。因为我的简历现在说自己是个“Kubernetes专家”，一个想法立刻诞生了：为什么不把我对这个系统的宽泛理解以及我已经耗费了几个小时的研究所收集的知识让更多人看到？虽然我无法说服自己不应该再写另一篇漫无目的的文章，但是我很快就明白了：
这就是那篇文章。
我在现有文章中遇到的主要问题是，在深入研究具体细节之前，我找不到的任何内容总结了这些组件是什么以及它们如何组合起来的高级概述。 而这种高屋建瓴的呈现方式是我学习最好的方式。我是以这种方式来写的，希望它也适合你。如果你知道任何描述了Kubernetes如何工作，而且让人容易理解的专家级的文章/教程，请不要告诉我，因为你在我需要你的时候你在哪里，现在我写了我的文章而你却没有及早把它拿出来。
另外请记住，我实际上只学习了Kubernetes一个星期左右，所以学得不会非常深入，有些可能是不准确的，尽管希望没有什么错误，这里的信息应该足够让你达到运行简单集群的程度。
话虽如此，最后我发现Kubernetes中的概念还是非常简单的，虽然我确信有很多东西我还不知道。但是，我知道的事情就足以建立一个集群并让我们的应用在其上运行，而且我很确定它们足以让大多数人知道如何开始。
基本概念 我们需要做的第一件事是详细介绍Kubernetes的各个部分：
 控制平面(Control plane)：顾名思义，这是控制其他一切的部分，这也是我一无所知的部分，因为我们只是向亚马逊付费，让亚马逊帮我们处理这部分。我的理解是，这是最好的决定，除非你是谷歌，否则你应该付费给一些公司，让他们为你管理。
 节点(Nodes)：节点本质上就是一台服务器，就像您付费的物理机worker一样。 这是所有代码部署的地方，将裸服务器变成节点的方法是在其上安装Docker，kubelet，kube-proxy和其他一些东西。本文假设您的群集中已有一些worker。
 容器集(Pods)：pod是容器集合。 这是您的代码所在的位置，通常每个容器都有一个pod，尽管您可能希望将一些密切相关的服务放在同一个pod中。 pod在单个节点上运行（但是一个节点可以运行许多pod），这意味着pod中的所有容器将具有相同的IP地址，并且它们可以通过连接到localhost上的彼此端口来相互通信。Pod在部署后无法更新，只能删除或替换它们。
 部署(Deployments)： Deployment是您将pod实际部署到群集的方式。 您可以在没有Deployment的情况下运行pod，但如果没有Deployment，则无法轻松指定所需的副本数量，在失败时自动重新部署pod，回滚到早期状态等。Deployment使代码生命周期管理变得更容易，并且您可以使用它来使Docker镜像在Kubernetes上运行。
 服务(Service)：服务允许您从一个pod打开端口到其他pod，并指定一个pod的DNS名称，以便能够查找并连接到群集中的其他pod。
 入口(Ingress)：Ingresses是你如何告诉你的Ingress控制器（通常是像Traefik这样的web server）向外界暴露什么，以及在哪个路径或主机名上。 入口将https://some-hostname.your-cluster.your-company.com映射到将实际应答该请求的pod。本教程也假设您已经配置了入口，虽然设置Traefik来做到这一点不应该非常困难（在用他们的教程时请使用Deployment方法）。
  所有这些都可以使用命令行的kubectl创建，或者更安全地通过YAML文件创建，该文件将包含您要部署的内容的定义和详细信息（然后执行kubectl apply -f &amp;lt;yaml file&amp;gt;。
概括地讲，您把容器放入pods中，这些pods将由deployment创建和部署，其网络将由service处理，并添加ingress以便外部世界可以访问您的服务器。
让我们逐个介绍这些部分，看看它们的YAML配置是什么样的。
The Pod 让我们看一下将在容器中运行redis镜像的pod的YAML配置。 请记住，pod并不是持久性的，所以你几乎不会直接使用它。 相反，您将使用deployment间接部署pod，我们将在下面介绍。
以下配置示例仅供您进行修改。 你只需要看看它，然后继续阅读，不要停下来惊叹它的美丽。
apiVersion: v1 kind: Pod metadata: name: my-pod-name spec: containers: - name: my-redis image: redis ports: - containerPort: 6379  正如您所看到的，它非常简单，您添加了一堆Kubernetes特定的东西，每个都只是复制粘贴，然后您声明此配置是为Pod，给它一个名称，指定在其中运行的容器和他们监听的端口，请删除整个文件吧，你已经准备好了！</description>
    </item>
    
    <item>
      <title>为何说kubernetes是新一代的应用服务器(译)</title>
      <link>https://kelvinji2009.github.io/blog/why-kubernetes-is-the-new-application-server/</link>
      <pubDate>Wed, 18 Jul 2018 21:53:43 +0800</pubDate>
      
      <guid>https://kelvinji2009.github.io/blog/why-kubernetes-is-the-new-application-server/</guid>
      <description>为何说kubernetes是新一代的应用服务器 原文
你有没有想过为什么你要使用容器部署你的多平台应用程序？这只是“跟随炒作”的问题吗？在本文中，我将要问一些挑衅性的问题，以说明为什么Kubernetes是新一代的应用服务器。
您可能已经注意到大多数语言都是被interpreted并使用runtime来执行您的源代码。 理论上，大多数Node.js，Python和Ruby代码可以轻松地从一个平台（Windows，Mac，Linux）迁移到另一个平台。 Java应用程序更进一步，通过将编译后的Java类转换为字节码，能够在具有JVM（Java虚拟机）的任何地方运行。
Java生态系统提供了一种标准格式，用于分发属于同一应用程序的所有Java类。 您可以将这些类打包为包含嵌入的前端，后端和库的JAR（Java归档），WAR（Web归档）和EAR（企业归档）。 那么我问你：为什么要使用容器来分发你的Java应用程序？ 难道它不应该在环境之间轻松移植吗？
从开发人员的角度回答这个问题并不总是显而易见的。 但请考虑一下您的开发环境以及由它与生产环境之间的差异引起的一些可能问题：
 你使用的是Mac，Windows还是Linux？ 您是否遇到过与&amp;rsquo;\&amp;lsquo;vs&amp;rsquo;/&amp;lsquo;作为文件路径分隔符相关的问题？ 你使用的是什么版本的JDK？ 你是否在开发中使用Java 10，但生产使用JRE 8？ 您是否遇到过JVM差异引入的错误？ 你使用的是什么版本的应用服务器？ 生产环境是否使用相同的配置，安全补丁和库版本？ 在生产部署期间，您是否遇到过由于驱动程序或数据库服务器的版本不同而导致的JDBC驱动程序问题，而在开发环境中却没有出现？ 你有没有遇到当你要求应用服务器管理员创建一个数据源或一个JMS队列的时候，它却包含一个错误的字符？  上述所有问题都是由应用程序外部因素引起的，容器最重要的一点是您可以部署所有应用程序（例如，Linux发行版，JVM，应用程序服务器，库，配置以及您的最终应用程序）在预先构建好的容器中。 另外，执行一个内置了所有内容的容器比将代码移动到生产环境并尝试在不工作时解决差异要容易得多。 由于它很容易执行，因此将同一容器水平扩展多个副本也变得很容易。
强化你的应用 在容器变得非常流行之前，应用程序服务器提供了几个Non-functional requirement，例如安全性，隔离性，容错性，配置管理等。 做个类比，应用程序好比CD，应用程序服务器就好比是CD播放器。
作为开发人员，您将负责遵循预定义的标准，并以特定格式分发应用程序，而另一方面，应用程序服务器将“执行”您的应用程序，并提供可能因不同“品牌”而异的其他功能。 在Java世界中，应用程序服务器提供的企业功能标准最近已在Eclipse基础之下有了新的发展。 基于Eclipse Enterprise for Java（EE4JEclipse Enterprise for Java）的工作已经诞生了Jakarta EE。 （欲了解更多信息，请阅读文章Jakarta EE正式发布或观看DevNation视频Jakarta EE：Java EE的未来。）
继续CD播放器的类比，随着容器的提升，容器镜像已经成为新的CD格式。 事实上，容器镜像只不过是分发容器的格式。（如果您需要更好地处理容器镜像以及它们如何分发，请参阅容器术语的实用介绍。）
当您需要向应用程序添加企业级功能时，才能体会到容器的真正好处。 向容器化应用程序提供这些功能的最佳方式是使用Kubernetes作为它们的平台。 此外，Kubernetes平台为其他项目（如Red Hat OpenShift，Istio和Apache OpenWhisk）提供了良好的基础，可以构建和部署强大的生产级别质量的应用程序。
让我们来探索其中的九个功能：
1-服务发现 服务发现是确定如何连接到某个服务的过程。 要获得容器和云原生应用程序的诸多好处，您需要从容器镜像中隔离配置，以便在所有环境中使用相同的容器镜像。 应用程序的外部化配置是12-factor应用程序的关键原则之一。 服务发现是从运行时环境获取配置信息的方法之一，而不是在应用程序中进行硬编码。 Kubernetes提供开箱即用的服务发现。 Kubernetes还提供ConfigMaps和Secrets以从应用程序容器中隔离配置。 Secerets解决了当您需要存储凭据以连接到运行时环境中的数据库等服务时出现的一些挑战。
使用Kubernetes，不需要使用外部服务器或框架。 尽管您可以通过Kubernetes YAML文件管理每个运行时环境的环境设置，但红帽OpenShift提供了一个GUI和CLI，可以让DevOps团队更容易管理。
2-基本调用 在容器内部运行的应用程序可以通过Ingress访问进行访问 - 换句话说，就是从外部世界到您正在暴露的服务。 OpenShift使用HAProxy提供路由对象，HAProxy具有多种功能和负载均衡策略。 您可以使用路由功能进行滚动部署。 这是一些非常复杂的CI / CD策略的基础。 请参阅下面的“6 - 构建和部署管道”。</description>
    </item>
    
  </channel>
</rss>